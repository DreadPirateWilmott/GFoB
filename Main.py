#Created by DreadPirateWilmott on November 14th 2013
#Last edited on the 4th of December
#Feel free to change, break, create, or mod anything about this game as you see fit


#Current Version 0.0.4 - 9 hours 35 minutes of recorded time

#import essential files
import time
import random
import math
import glob
import os

def genW():
	print "Generating world..."
	tileList = []
	tileNlist = []
	for x in range(1, 21):
		for z in range(1, 21):
			for y in range(1, 21):
				if y < 18:
					if y >= 16:
						dirtChance = random.randint(1, 11)
						if dirtChance == 1:
							tileName = "dirt"
						else:
							tileName = "stone"
					else:
						tileName = "stone"
				elif y >= 18:
					airChance = random.randint(1,3)
					if airChance == 1:
						tileName = "air"
					else:
						tempY = y - 1
						tempCompile = "%s.%s.%s" % (x, tempY, z)
						if tempCompile not in tileList: #Air
							tileName = "air"
						else:
							tileName = "dirt"
					#end if
					
				if tileName != "air":
					compile = "%s.%s.%s" % (x, y, z)
					tileList.append(compile)
					tileNlist.append(tileName)
	return tileList, tileNlist
	
def Menu():
	print "[Start] New Game"
	print "[Load] Game"
	print "Tutorial"
	print "Controls"
	cMenu = str(raw_input(": ").lower())
	
	if cMenu == "start" or cMenu == "load":
		GFoB(cMenu)
	elif cMenu == "tutorial":
		Tutorial()
	elif cMenu == "controls":
		ControlPrint()
	#end if

def ControlPrint():
	print "To understand the controls you need to understand how I refer to commands. There are three types: primary, secondary, tertiary."
	print "Primary commands are the first word and the identifier. Secondary commands are generally directions. Tertiary commands are only used for distance."
	print "In the game there are currently 5 commands that need to be listed: move, place, turn, mine, and shoot."
	print "Move - Primary command, Forward, Back, Left, Right - Secondary command, No tertiary command."
	print "Place - Primary command, Forward, Back, Left, Right - Secondary command, Tertiary command is distance (up to four spaces)."
	print "Mine - Primary command, Forward, Back, Left, Right - Secondary command, Tertiary command is distance (up to four spaces)."
	print "Turn - Primary command, Right, Left - Secondary command, No tertiary command."
	Menu()
	
def Tutorial():
	print "The purpose of the game is to build, manage, and successfully defend a fortress."
	print "See the controls menu located in the main menu for more information on key bindings."
	Menu()
	
def GFoB(cMenu):
	if cMenu == "start":
		files = glob.glob("*.txt")
		searchI = "natterrain.txt"
		if searchI in files:
			os.remove(searchI)
		searchI = "unatterrain.txt"
		if searchI in files:
			os.remove(searchI)
		searchI = "boundaries.txt"
		if searchI in files:
			os.remove(searchI)
		searchI = "playersave.txt"
		if searchI in files:
			os.remove(searchI)
		searchI = "inventory.txt"
		if searchI in files:
			os.remove(searchI)
		#end if
		charN = str(raw_input("Enter character name: "))
		playerX = 1
		playerZ = 1
		playerY = 21
		faceDir = 1 #The direction that you are facing; defaults to forward being + on the X
		compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
		naturalTiles = [] #These are only the blocks generated by the world
		tileList = [] #Format for blocklist is the X coordinate. Y coordinate. Z coordinate
		inventory = [] #This is the inventory of the player
		emptyList = [] #This list contains unimportant information
		tileNlist = [] #This list corresponds with tileList, all items in tileList have the same value in here, but they have the tile name
		#Adding to blocklist
		generation, names = genW()
		tileList = tileList + generation
		naturalTiles = naturalTiles + generation
		tileNlist = tileNlist + names
	elif cMenu == "load":
		emptyList = []
		#Load the game from the save state files
		
		#Load the player save
		file = open("playersave.txt", "r")
		tempCompile = file.read()
		playerSplit = tempCompile.split(".")
		
		#Get the X, Y, Z, and direction
		playerX = int(playerSplit[0])
		playerY = int(playerSplit[1])
		playerZ = int(playerSplit[2])
		faceDir = int(playerSplit[3])
		charN = str(playerSplit[4])
		file.close()
		
		#Load the inventory
		file = open("inventory.txt", "r")
		inventory = file.read()
		
		#Get the players inventory
		inventory = inventory.split(", ")
		file.close()
		
		#Load the natural blocks
		file = open("natterrain.txt", "r")
		natterrain = file.read()
		
		#Get the natural terrain blocks
		naturalTiles = natterrain.split(", ")
		file.close()
		
		#Load the blockList
		file = open("unatterrain.txt", "r")
		unatterrain = file.read()
		
		#Get the blockList
		tileList = unatterrain.split(", ")
		file.close()
		
		#Get the tile names
		file = open("existingtiles.txt", "r")
		tiles = file.read()
		
		#Get the tile name list
		tileNlist = tiles.split(", ")
		file.close()
		
		#Load the fortress boundaries if the file exists
		files = glob.glob("*.txt")
		searchI = "boundaries.txt"
		if searchI in files:
			file = open("boundaries.txt", "r")
			tempCompile = file.read()
			tempCompile = tempCompile.split(".")
			
			#Load the files from temp compile
			forXplusBound = int(tempCompile[0])
			forXminusBound = int(tempCompile[1])
			forZplusBound = int(tempCompile[2])
			forXminusBound = int(tempCompile[3])
		
			emptyList.append("true")
		#end if
	#end if
	while True: #Loop forever, there will be a command to end the game
		print inventory
		#Moving down will be done automatically by the game
		tempX = playerX + 1
		tempY = playerY - 1
		if faceDir == 1:
			tempCompile = "%s.%s.%s" % (tempX, tempY, playerZ)
			tempCompile2 = "%s.%s.%s" % (playerX, tempY, playerZ)
		elif faceDir == 2:
			tempZ = playerZ + 1
			tempY = playerY - 1
			tempCompile = "%s.%s.%s" % (playerX, tempY, tempZ)
			tempCompile2 = "%s.%s.%s" % (playerX, tempY, playerZ)
		elif faceDir == 3:
			tempX = playerX - 1
			tempY = playerY - 1
			tempCompile = "%s.%s.%s" % (tempX, tempY, playerZ)
			tempCompile2 = "%s.%s.%s" % (playerX, tempY, playerZ)
		elif faceDir == 4:
			tempZ = playerZ - 1
			tempY = playerY - 1
			tempCompile = "%s.%s.%s" % (playerX, tempY, tempZ)
			tempCompile2 = "%s.%s.%s" % (playerX, tempY, playerZ)
		#end if
		droppS = 0 # dropped spaces
		while tempCompile not in tileList and tempCompile2 not in tileList and playerY > 1:
			playerY -= 1
			droppS += 1
			tempY = playerY - 1
			tempCompile = "%s.%s.%s"  % (tempX, tempY, playerZ)
			tempCompile2 = "%s.%s.%s" % (playerX, tempY, playerZ)
		#end while
		if droppS > 0:
			print charN + " fell %s space(s)" % (droppS)
		print "%s's current position is %s X, %s Y, and %s Z" % (charN, playerX, playerY, playerZ)
		if faceDir == 1:
			tempX = playerX + 1
			tempCompile = "%s.%s.%s" % (tempX, playerY, playerZ)
			if tempCompile in tileList:
				print "Tile forward"
			tempZ = playerZ + 1
			tempCompile = "%s.%s.%s" % (playerX, playerY, tempZ)
			if tempCompile in tileList:
				print "Tile right"
			tempX = playerX - 1
			tempCompile = "%s.%s.%s" % (tempX, playerY, playerZ)
			if tempCompile in tileList:
				print "Tile back"
			tempZ = playerZ - 1
			tempCompile = "%s.%s.%s" % (playerX, playerY, tempZ)
			if tempCompile in tileList:
				print "Tile left"
			#end if
		elif faceDir == 2:
			tempZ = playerZ + 1
			tempCompile = "%s.%s.%s" % (playerX, playerY, tempZ)
			if tempCompile in tileList:
				print "Tile forward"
			tempX = playerX - 1
			tempCompile = "%s.%s.%s" % (tempX, playerY, playerZ)
			if tempCompile in tileList:
				print "Tile right"
			tempZ = playerZ - 1
			tempCompile = "%s.%s.%s" % (playerX, playerY, tempZ)
			if tempCompile in tileList:
				print "Tile back"
			tempX = playerX + 1
			tempCompile = "%s.%s.%s" % (tempX, playerY, playerZ)
			if tempCompile in tileList:
				print "Tile left"
			#end if
		elif faceDir == 3:
			tempX = playerX - 1
			tempCompile = "%s.%s.%s" % (tempX, playerY, playerZ)
			if tempCompile in tileList:
				print "Tile forward"
			tempZ = playerZ - 1
			tempCompile = "%s.%s.%s" % (playerX, playerY, tempZ)
			if tempCompile in tileList:
				print "Tile right"
			tempX = playerX + 1
			tempCompile = "%s.%s.%s" % (tempX, playerY, playerZ)
			if tempCompile in tileList:
				print "Tile back"
			tempZ = playerZ + 1
			tempCompile = "%s.%s.%s" % (playerX, playerY, tempZ)
			if tempCompile in tileList:
				print "Tile left"
			#end if
		elif faceDir == 4:
			tempZ = playerZ - 1
			tempCompile = "%s.%s.%s" % (playerX, playerY, tempZ)
			if tempCompile in tileList:
				print "Tile forward"
			tempX = playerX + 1
			tempCompile = "%s.%s.%s" % (tempX, playerY, playerZ)
			if tempCompile in tileList:
				print "Tile right"
			tempZ = playerZ + 1
			tempCompile = "%s.%s.%s" % (playerX, playerY, tempZ)
			if tempCompile in tileList:
				print "Tile back"
			tempX = playerX - 1
			tempCompile = "%s.%s.%s" % (tempX, playerY, playerZ)
			if tempCompile in tileList:
				print "Tile left"
			#end if
		#end if
		tempY = playerY - 1
		tempCompile = "%s.%s.%s" % (playerX, tempY, playerZ)
		if tempCompile in tileList:
			print "No block below"
		#end if
		instruction = str(raw_input(": ").lower())
		if "move" in instruction or "mv" in instruction: #Ex move forward
			#The player wishes to move in one of the four directions
			moveList = instruction.split(" ")
			moveDirection = moveList[1]
			if len(moveList) == 3:
				moveDistance = int(moveList[2])
				if moveDistance > 5:
					moveDistance = 5
				elif moveDistance < 0:
					moveDistance = 0
				#end if
			else:
				moveDistance = 1
			#The move direction will determine which way the player moves; the direction is relative to the direction
			#that the player is facing.
			for i in range(0, moveDistance):
				if moveDirection == "forward" or moveDirection == "f": 
					if faceDir == 1:
						playerX += 1
						compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
						if compiledCo in tileList:
							playerX -= 1
							print "Blocked path"
					elif faceDir == 2:
						playerZ += 1
						compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
						if compiledCo in tileList:
							playerZ -= 1
							print "Blocked path"
					elif faceDir == 3:
						playerX -= 1
						compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
						if compiledCo in tileList:
							playerX += 1
							print "Blocked path"
					elif faceDir == 4:
						playerZ -= 1
						compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
						if compiledCo in tileList:
							playerZ += moveDistance
							print "Blocked path"
				elif moveDirection == "back" or moveDirection == "b":
					if faceDir == 1:
						playerX -= 1
						compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
						if compiledCo in tileList:
							playerX += 1
							print "Blocked path"
					elif faceDir == 2:
						playerZ  -= 1
						compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
						if compiledCo in tileList:
							playerZ += 1
							print "Blocked path"
					elif faceDir == 3:
						playerX += 1
						compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
						if compiledCo in tileList:
							playerX -= 1
							print "Blocked path"
					elif faceDir == 4:
						playerZ += 1
						compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
						if compiledCo in tileList:
							playerZ -= 1
							print "Blocked path"
				elif moveDirection == "right" or moveDirection == "r":
					if faceDir == 1:
						playerZ += 1
						compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
						if compiledCo in tileList:
							playerZ -= 1
							print "Blocked path"
					elif faceDir == 2:
						playerX -= 1
						compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
						if compiledCo in tileList:
							playerX += 1
							print "Blocked path"
					elif faceDir == 3:
						playerZ -= 1
						compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
						if compiledCo in tileList:
							playerZ += 1
							print "Blocked path"
					elif faceDir == 4:
						playerX += 1
						compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
						if compiledCo in tileList:
							playerX -= 1
							print "Blocked path"
				elif moveDirection == "left" or moveDirection == "l":
					if faceDir == 1:
						playerZ -= 1
						compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
						if compiledCo in tileList:
							playerZ += 1
							print "Blocked path"
					elif faceDir == 2:
						playerX += 1
						compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
						if compiledCo in tileList:
							playerX -= 1
							print "Blocked path"
					elif faceDir == 3:
						playerZ += 1
						compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
						if compiledCo in tileList:
							playerZ -= 1
							print "Blocked path"
					elif faceDir == 4:
						playerX -= 1
						compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
						if compiledCo in tileList:
							playerX += 1
							print "Blocked path"
				elif moveDirection == "climb" or moveDirection == "c": #To move upwards the block you wish to climb needs to be in front of you
					if faceDir == 1:
						tempX = playerX + 1 #This is a temporary, unimportant value that is used for testing location conditions
						tempCompile = "%s.%s.%s" % (tempX, playerY, playerZ)
					elif faceDir == 2:
						tempZ = playerZ + 1
						tempCompile = "%s.%s.%s" % (playerX, playerY, tempZ)
					elif faceDir == 3:
						tempX = playerX - 1
						tempCompile = "%s.%s.%s" % (tempX, playerY, playerZ)
					elif faceDir == 4:
						tempZ = playerZ - 1
						tempCompile = "%s.%s.%s" % (playerX, playerY, tempZ)
					if(tempCompile in tileList):
						playerY += 1
						print "Climb succesful"
					else:
						print "Climb unsuccessful"
					compiledCo = "%s.%s.%s" % (playerX, playerY, playerZ)
					if compiledCo in tileList:
						playerY -= 1
						print "Blocked path"
					#end if
				#end for
				elif moveDirection == "down" or moveDirection == "d":
					tempY = playerY - 1
					tempCompile = "%s.%s.%s" % (playerX, playerY, playerZ)
					if tempCompile not in tileList: 
						playerY -= 1
					else:
						print "Blocked path"
					#end if
				#end for
			#If the player moves off of the platform then reset their position

			if len(emptyList) > 0:
				if playerX > forXplusBound or playerX < forXminusBound or playerZ > forZplusBound or playerZ < forZminusBound:
					print charN + " has travelled out of the fortress."
			if playerX > 20 or playerX < 1 or playerZ > 20 or playerZ < 1:
				print "Player position reset"
				playerX = 1
				playerZ = 1
				playerY = 21
				faceDir = 1
			#end if
		#end if
		elif "turn" in instruction or "trn" in instruction: #Ex turn.right
			#The player wishes to turn in one of the two directions
			#1 = X+, 2 = Z+, 3 = X-, 4 = Z-
			directionList = instruction.split(" ")
			direction = directionList[1]
			if direction == "right" or direction == "r":
				faceDir += 1
				if faceDir == 5:
					faceDir = 1
			elif direction == "left" or direction == "l":
				faceDir -= 1
				if faceDir == 0:
					faceDir = 4
		#end if
		elif "place" in instruction or "plc" in instruction: #Ex place.forward
			#The player wishes to place an object in one of the four directions
			placeList = instruction.split(" ")
			direction = placeList[1]
			tileType = "" #Default
			
			if direction == "crefor" and len(emptyList) == 0:
				placeDis = 1
				emptyListTrig = True
				
				#Determine the boundaries for the fortress
				forXplusBound = playerX + int(raw_input("X Positive boundary distance: "))
				forXminusBound = playerX - int(raw_input("X Negative boundary distance: "))
				forZplusBound = playerZ + int(raw_input("Z Positive boundary distance: "))
				forZminusBound = playerZ - int(raw_input("Z Negative boundary distance: "))

			else:
				emptyListTrig = False
			if len(placeList) == 3:
				try:
					placeDis = int(placeList[2])
				except ValueError: #Identifying block not distance
					placeDis = 1
					tileType = str(placeList[2])
			elif len(placeList) == 4:
				placeDis = int(placeList[2])
				tileType = str(placeList[3])
			else:
				placeDis = 1
				emptyListTrig = False
			#Make sure the place distance doesn't exceed 4
			if placeDis > 4:
				placeDis = 4
				print "Distance too great, tile will be placed 4 blocks away."
				
			if direction == "forward" or direction == "f":
				if faceDir == 1:
					blockX = playerX + placeDis
					compiledTile = "%s.%s.%s" % (blockX, playerY, playerZ)
				elif faceDir == 2:
					blockZ = playerZ + placeDis
					compiledTile = "%s.%s.%s" % (playerX, playerY, blockZ)
				elif faceDir == 3:
					blockX = playerX - placeDis
					compiledTile = "%s.%s.%s" % (blockX, playerY, playerZ)
				elif faceDir == 4:
					blockZ = playerZ - placeDis
					compiledTile = "%s.%s.%s" % (playerX, playerY, blockZ)
			elif direction == "back" or direction == "b":
				if faceDir == 1:
					blockX = playerX - placeDis
					compiledTile = "%s.%s.%s" % (blockX, playerY, playerZ)
				elif faceDir == 2:
					blockZ = playerZ - placeDis
					compiledTile = "%s.%s.%s" % (playerX, playerY, blockZ)
				elif faceDir == 3:
					blockX = playerX + placeDis
					compiledTile = "%s.%s.%s" % (blockX, playerY, playerZ)
				elif faceDir == 4:
					blockZ = playerZ + placeDis
					compiledTile = "%s.%s.%s" % (playerX, playerY, blockZ)
			elif direction == "left" or direction == "l":
				if faceDir == 1:
					blockZ = playerZ - placeDis
					compiledTile = "%s.%s.%s" % (playerX, playerY, blockZ)
				elif faceDir == 2:
					blockX = playerX + placeDis
					compiledBlock = "%s.%s.%s" % (blockX, playerY, playerZ)
				elif faceDir == 3:
					blockZ = playerZ + placeDis
					compiledTile = "%s.%s.%s" % (playerX, playerY, blockZ)
				elif faceDir == 4:
					blockX = playerX - placeDis
					compiledTile = "%s.%s.%s" % (blockX, playerY, playerZ)
			elif direction == "right" or direction == "r":
				if faceDir == 1:
					blockZ = playerZ + placeDis
					compiledTile = "%s.%s.%s" % (playerX, playerY, blockZ)
				elif faceDir == 2:
					blockX = playerX - placeDis
					compiledTile = "%s.%s.%s" % (blockX, playerY, playerZ)
				elif faceDir == 3:
					blockZ = playerZ - placeDis
					compiledTile = "%s.%s.%s" % (playerX, playerY, blockZ)
				elif faceDir == 4:
					blockX = playerX + placeDis
					compiledTile = "%s.%s.%s" % (blockX, playerY, playerZ)
			elif direction == "up":
				blockY = playerY + placeDis
				compiledTile = "%s.%s.%s" % (playerX, blockY, playerZ)
			elif direction == "down" or direction == "dwn" and playerY > 1:
				blockY = playerY - placeDis
				compiledTile = "%s.%s.%s" % (playerX, blockY, playerZ)
			#end if
			
			#Add compiledBlock to the total blocklist
			if emptyListTrig == True:
				emptyList.append("true")
			else:
				possibleTiles = ["stone", "dirt"] #MOD NOTICE - Any blocks created have to be added here
				if tileType not in possibleTiles or tileType not in inventory:
					print "Not a valid tile / Not available in inventory"
				else:
					if compiledTile not in tileList:
						tileNlist.append(tileType)
						tileList.append(compiledTile)
					else:
						print "Tile already in that location"
		#end if
		elif "mine" in instruction or "mn" in instruction:
			mineList = instruction.split(" ")
			direction = mineList[1]
			if len(mineList) == 3:
				mineDis = int(mineList[2])
			else:
				mineDis = 1
			#If the mining distance is greater than 4 than reduce the distance to 4
			if mineDis > 4:
				mineDis = 4
				print "Too far away, tile will be mined 4 blocks away."
				
			#Determine the direction and facing direction in an attempt to remove the block
			if direction == "forward" or direction == "f":
				if faceDir == 1:
					blockX = playerX + mineDis
					compiledTile = "%s.%s.%s" % (blockX, playerY, playerZ)
				elif faceDir == 2:
					blockZ = playerZ + mineDis
					compiledTile = "%s.%s.%s" % (playerX, playerY, blockZ)
				elif faceDir == 3:
					blockX = playerX - mineDis
					compiledTile = "%s.%s.%s" % (blockX, playerY, playerZ)
				elif faceDir == 4:
					blockZ = playerZ - mineDis
					compiledTile = "%s.%s.%s" % (playerX, playerY, blockZ)
			elif direction == "back" or direction == "b":
				if faceDir == 1:
					blockX = playerX - mineDis
					compiledTile = "%s.%s.%s" % (blockX, playerY, playerZ)
				elif faceDir == 2:
					blockZ = playerZ - mineDis
					compiledTile = "%s.%s.%s" % (playerX, playerY, blockZ)
				elif faceDir == 3:
					blockX = playerX + mineDis
					compiledTile = "%s.%s.%s" % (blockX, playerY, playerZ)
				elif faceDir == 4:
					blockZ = playerZ + mineDis
					compiledTile = "%s.%s.%s" % (playerX, playerY, blockZ)
			elif direction == "left" or direction == "l":
				if faceDir == 1:
					blockZ = playerZ - mineDis
					compiledTile = "%s.%s.%s" % (playerX, playerY, blockZ)
				elif faceDir == 2:
					blockX = playerX + mineDis
					compiledTile = "%s.%s.%s" % (blockX, playerY, playerZ)
				elif faceDir == 3:
					blockZ = playerZ + mineDis
					compiledTile = "%s.%s.%s" % (playerX, playerY, blockZ)
				elif faceDir == 4:
					blockX = playerX - mineDis
					compiledTile = "%s.%s.%s" % (blockX, playerY, playerZ)
			elif direction == "right" or direction == "r":
				if faceDir == 1:
					blockZ = playerZ + mineDis
					compiledTile = "%s.%s.%s" % (playerX, playerY, blockZ)
				elif faceDir == 2:
					blockX = playerX - mineDis
					compiledTile = "%s.%s.%s" % (blockX, playerY, playerZ)
				elif faceDir == 3:
					blockZ = playerZ - mineDis
					compiledTile = "%s.%s.%s" % (playerX, playerY, blockZ)
				elif faceDir == 4:
					blockX = playerX + mineDis
					compiledTile = "%s.%s.%s" % (blockX, playerY, playerZ)
			elif direction == "up":
				blockY = playerY + mineDis
				compiledTile = "%s.%s.%s" % (playerX, blockY, playerZ)
			elif direction == "down" or direction == "dwn" and playerY > 1:
				blockY = playerY - mineDis
				compiledTile = "%s.%s.%s" % (playerX, blockY, playerZ)
			#end if
			
			if compiledTile in naturalTiles:
				
				rsrcLck = random.randint(1, 101)
				if rsrcLck >= 1 and rsrcLck <= 25: #1 in 4 chance for coal
					inventory.append("coal")
					print "Mined 1 coal"
					oreMined = True
				elif rsrcLck > 25 and rsrcLck <= 45: #1 in 4 (about) chance for iron
					inventory.append("ir_ore")
					print "Mined 1 iron ore"
					oreMined = True
				else:
					oreMined = False
				#end if
				naturalTiles.remove(compiledTile)
				#Remove the block
			else:
				oreMined = False
			if compiledTile in tileList:
				searchI = tileList.index(compiledTile)
				removedItem = tileNlist[searchI]
				tileNlist.pop(searchI)
			
				tileList.remove(compiledTile)
				
				if oreMined == False:
					print "Tile mined: %s" % (removedItem)
					#Add the mined block to the inventory of the player
					inventory.append(removedItem)
				else:
					print "Tile mined"
				#end if
			else:
				print "No tile to mine"
			#end if
			
		elif instruction == "shoot": #Ex shoot
			#The player wishes to shoot
			if faceDir == 1:
				for i in range(1, 21):
					tempX = playerX + i
					compiledValue = "%s.%s.%s" % (tempX, playerY, playerZ)
					if compiledValue in tileList:
						print "Blocked by object"
						break
			elif faceDir == 2:
				for i in range(1, 21):
					tempZ = playerZ + i
					compiledValue = "%s.%s.%s" % (playerX, playerY, tempZ)
					if compiledValue in tileList: 
						print "Blocked by object"
						break
			elif faceDir == 3:
				for i in range(1, 21):
					tempX = playerX - i
					compiledValue = "%s.%s.%s" % (tempX, playerY, playerZ)
					if compiledValue in tileList:
						print "Blocked by object"
						break
			elif faceDir == 4:
				for i in range(1, 21):
					tempZ = playerZ - i
					compiledValue = "%s.%s.%s" % (playerX, playerY, tempZ)
					if compiledValue in tileList:
						print "Blocked by object"
						break
			#end if
		#end if
		elif instruction == "functions" or "functions" in instruction:
			#The player wants to smelt, build, or manage
			funcMan = instruction.split(" ")
			coalc = 0 #Coal count
			searchI = "coal"
			for searchI in inventory:
				coalc += 1
			#end for
			ir_orec = 0 #Iron ore count
			searchI = "ir_ore"
			for searchI in inventory:
				ir_orec += 1
			#end for
			if len(funcMan) == 1: #They didn't pass any arguments to the function
				print "Menu: Smelt, Build, Manage"
				openSpC = str(raw_input(": ").lower())
			elif len(funcMan) >= 1:
				openSpC = funcMan[1]
			#end if
			if openSpC == "smelt":
				#Make sure the player has enough iron and coal
				loopc = 0
				if ir_orec >= 5 and coalc >= 1:
					while ir_orec >= 5 and coalc >= 1:
						loopc += 5
						for i in range(1, 6):
							inventory.append("iron_bar")
							inventory.remove("ir_ore")
							
							#Remove both items
						ir_orec -= 5
						coalc -= 1
						#end for
						inventory.remove("coal")
					#end while
					print "You smelted %s iron bars." % (loopc)
				else:
					print "You don't have enough resources." 
				#end if
			
		elif instruction == "save game":
			#Save the game
			#Need to save X, Y, Z, and facing direction
			#Need to save inventory, naturalBcks, and blockList lists
			files = glob.glob("*.txt")
			searchI = "natterrain.txt"
			if searchI in files:
				os.remove(searchI)
			searchI = "unatterrain.txt"
			if searchI in files:
				os.remove(searchI)
			searchI = "boundaries.txt"
			if searchI in files:
				os.remove(searchI)
			searchI = "playersave.txt"
			if searchI in files:
				os.remove(searchI)
			searchI = "inventory.txt"
			if searchI in files:
				os.remove(searchI)
			searchI = "existingtiles.txt"
			if searchI in files: 
				os.remove(searchI)
			#end if
			
			#Save the player position and info
			file = open("playersave.txt", "w")
			tempCompile = "%s.%s.%s.%s.%s" % (playerX, playerY, playerZ, faceDir, charN)
			file.write(tempCompile)
			file.close()
			
			#Save the inventory of the player
			file = open("inventory.txt", "w")
			inventory = ", ".join(inventory)
			file.write(str(inventory))
			file.close()
			
			#Save the natural blocks so the world knows when mining if you can get resources
			file = open("natterrain.txt", "w")
			natterrain = ", ".join(naturalTiles)
			file.write(str(natterrain))
			file.close()
			
			#Save the blockList so when loading the world the structures are saved
			file = open("unatterrain.txt", "w")
			unatterrain = ", ".join(tileList)
			file.write(str(unatterrain))
			file.close()
			
			#Save the tile names
			file = open("existingtiles.txt", "w")
			tiles = ", ".join(tileNlist)
			file.write(str(tiles))
			file.close()
			
			#Save the fortress boundaries
			if len(emptyList) == 1:
				file = open("boundary.txt", "w")
				tempCompile = "%s.%s.%s.%s" % (forXplusBound, forXminusBound, forZplusBound, forZminusBound)
				file.write(tempCompile)
				file.close()
			#end if
			#Close the game
			import sys
			sys.exit()
		
Menu()
